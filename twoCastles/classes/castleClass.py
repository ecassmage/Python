import pygame
from classes import unitsClass
import json
settings = json.load(open('settings.json', 'r'))


class Castle:
    def __init__(self, image, window, coord, team, bounds):  # calls/passes the information I guess.
        self.can_move = False
        self.window = window  # holds the screen this object is on
        self.scale = settings['window']['unit_size'] * 3
        self.image = pygame.transform.scale(image, (self.scale, self.scale))  # The objects image
        self.x, self.y, self.xy = coord[0], coord[1], coord  # The current coordinate this image is located
        self.spawn_coordinate = (self.x + 22.5, self.y + 45)  # Where the soldiers will spawn
        self.team, self.type = team, 'castle'  # Key words for either team specific stuff or object specific
        self.hp = settings['castle']['hp']  # Health of Castle
        self.regeneration = settings['castle']['regeneration'] / settings['fps']  # Speed of regeneration
        self.armor = settings['castle']['armor']  # Amount of Armor
        self.range = settings['castle']['range']  # range of projectiles generated by Castle
        self.cooldown = settings['castle']['cooldown']  # time between castles firing projectiles
        self.attacked_last = settings['castle']['cooldown']  # time since the last projectile was fired
        self.bounds = bounds  # Eh was gonna use it. not currently active, maybe later, dunno
        self.coins = settings['game']['cash']  # Current amount of cash on hand for castle
        self.next_round_coins = 0  # Current stockpile of achievement bonus
        self.coins_pot = settings['game']['cash start']  # How much you are going to get by default per round can vary
        self.score = 200  # Current Score for scoreboard
        self.recruitment_delay = settings['castle']['delay_recruit']  # Delay between soldiers being called
        self.lay_over = settings['castle']['delay_recruit']  # time between recruitment of individual soldiers
        self.soldiers, self.total_soldiers = [], 0  # This keeps track of all the units and projectiles of the team
        self.per_time_soldiers = settings['window']['per_turn_soldiers']  # Max soldiers spawnable per round
        self.queue = []  # Queue to spawn will help keep quick track.
        self.rectangle = self.image.get_rect(x=self.x, y=self.y)  # holds detailed information of current positioning
        self.resize_castle()

    def resize_castle(self):
        if self.team == 'red':
            # self.x =
            # self.xy =
            self.spawn_coordinate = (self.x + self.scale*0.45, self.y + self.scale)
        else:
            self.x -= self.scale
            self.xy = (self.x, self.y)
            self.spawn_coordinate = (self.x + self.scale*0.45, self.y + self.scale)

    def generate_new_soldier(self, type_soldier):
        temp_obj = None
        if type_soldier == 'footman':
            temp_obj = unitsClass.Footman(self.window,
                                          self.team,
                                          self.spawn_coordinate,
                                          )
        elif type_soldier == 'cheetah':
            temp_obj = unitsClass.Cheetah(self.window,
                                          self.team,
                                          self.spawn_coordinate,
                                          )
        elif type_soldier == 'archer':
            temp_obj = unitsClass.Archer(self.window,
                                         self.team,
                                         self.spawn_coordinate,
                                         )
        elif type_soldier == 'catapult':
            temp_obj = unitsClass.Catapult(self.window,
                                           self.team,
                                           self.spawn_coordinate,
                                           )
        elif type_soldier == 'tank':
            temp_obj = unitsClass.Tank(self.window,
                                       self.team,
                                       self.spawn_coordinate,
                                       )

        self.soldiers.append(temp_obj)
        return

    def rect_position(self):
        return self.image.get_rect(x=self.x, y=self.y)
